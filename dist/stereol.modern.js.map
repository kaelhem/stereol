{"version":3,"file":"stereol.modern.js","sources":["../src/stl-utils.js","../src/ascii-stl.js","../src/colors.js","../src/binary-stl.js","../src/index.js"],"sourcesContent":["/**\n * Heavily inspired by https://github.com/tmpvar/stl\n * Allow to create .stl content as ASCII or binary in NodeJS and browser.\n */\nexport const computeNormal = ([a, b, c]) => {\n  const [x0, y0, z0] = a\n  const [x1, y1, z1] = b\n  const [x2, y2, z2] = c\n  const [p1x, p1y, p1z] = [x1 - x0, y1 - y0, z1 - z0]\n  const [p2x, p2y, p2z] = [x2 - x0, y2 - y0, z2 - z0]\n  const [p3x, p3y, p3z] = [\n    p1y * p2z - p1z * p2y,\n    p1z * p2x - p1x * p2z,\n    p1x * p2y - p1y * p2x\n  ]\n  const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z)\n  if (mag === 0) {\n    return [0, 0, 0]\n  }\n  return [p3x, p3y, p3z].map(p => p / mag)\n}","import { computeNormal } from './stl-utils'\n\nconst trim = (a) => {\n  let nullTerm = a.indexOf('\\u0000')\n  if (nullTerm > -1) {\n    a = a.substr(0, nullTerm)\n  }\n  return a.trim()\n}\n\nconst exp = (x, y, z) => ([x, y, z].map(x => x.toExponential()))\n\nconst asciiFacet = (n, v) => (\n`facet normal ${exp(...n).join(' ')}\n  outer loop\n    vertex ${exp(...v[0]).join(' ')}\n    vertex ${exp(...v[1]).join(' ')}\n    vertex ${exp(...v[2]).join(' ')}\n  endloop\nendfacet\n`)\n\nexport const toASCII = (facets, description = '') => {\n  let str = 'solid ' + description.split(' COLOR=')[0].trim() + '\\n'\n  for (let j = 0; j < facets.length; j++) {\n    const facet = facets[j]\n    const v = facet.verts\n    const n = facet.normal || computeNormal(v)\n    str += asciiFacet(n, v)\n  }\n  str += 'endsolid'\n  return str\n}\n\nexport const fromASCII = (data) => {\n  const [desc, ...lines] = data.split('\\n').filter(x => x.trim() !== '')\n  const facets = []\n  let lineIndex = 0\n  let broken = false\n  while (!broken && lineIndex < lines.length && lines[lineIndex].indexOf('endsolid') === -1) {\n    broken = lines.length < lineIndex + 6\n    broken = broken || lines[lineIndex].indexOf('normal ') === -1\n    broken = broken || lines[lineIndex + 2].indexOf('vertex ') === -1\n    broken = broken || lines[lineIndex + 3].indexOf('vertex ') === -1\n    broken = broken || lines[lineIndex + 4].indexOf('vertex ') === -1\n    if (!broken) {\n      facets.push({\n        normal: lines[lineIndex].split('normal ')[1].trim().split(' ').map(x => parseFloat(x)),\n        verts: [\n          lines[lineIndex + 2].split('vertex ')[1].trim().split(' ').map(x => parseFloat(x)),\n          lines[lineIndex + 3].split('vertex ')[1].trim().split(' ').map(x => parseFloat(x)),\n          lines[lineIndex + 4].split('vertex ')[1].trim().split(' ').map(x => parseFloat(x))\n        ]\n      })\n      lineIndex += 7\n    }\n  }\n  if (broken) {\n    throw new Error('This file is not formatted correctly.')\n  }\n  return {\n    description : desc.slice(6),\n    facets\n  }\n}","const limited = (value, max = 0xFF) => Math.max(0, Math.min(max, parseInt(value, 10)))\nconst facetColorPart = (part) => limited(part, 31).toString(2).padStart(5, '0')\nconst stlColorPart = (part) => limited(part).toString(2).padStart(8, '0')\n\nexport default {\n  /*\n  Computes a 16 bits BGR color with this format: \n  bits 0 to 4 are the intensity level for blue (0 to 31),\n  bits 5 to 9 are the intensity level for green (0 to 31),\n  bits 10 to 14 are the intensity level for red (0 to 31),\n  bit 15 is 1 if the color is valid, or 0 if the color is not valid (as with normal STL files).\n  */\n  getFacetColor: ([r, g, b]) => Number(`0b${ facetColorPart(b) }${ facetColorPart(g) }${ facetColorPart(r) }1`),\n\n  /* Computes a 32 bits RGBA color */\n  getStlColor: ([r, g, b, a]) => Number(`0b${ stlColorPart(r) }${ stlColorPart(g) }${ stlColorPart(b) }${ stlColorPart(a) }`),\n}","import Colors from './colors'\nimport { computeNormal } from './stl-utils'\n\nlet IS_NODEJS = undefined\ntry {\n  IS_NODEJS = Boolean(Buffer)\n} catch (e) {\n  IS_NODEJS = false\n}\n\nconst writeBufferString = (buffer, value = '', offset = 0) => {\n  let step = 0\n  value.split('').forEach(char => {\n    buffer.setUint8(offset + step, char.charCodeAt(0))\n    ++step\n  })\n}\n\nconst createBuffer = (size) => {\n  const buffer = IS_NODEJS ? Buffer.alloc(size) : new DataView(new ArrayBuffer(size))\n  if (IS_NODEJS) {\n    buffer.fill(0, 0, 80)\n  }\n  return {\n    writeBuffer: (type, value, offset = 0) => {\n      switch (type) {\n        case 'uint8': return IS_NODEJS ? buffer.writeUInt8(value, offset) : buffer.setUint8(offset, value)\n        case 'uint16': return IS_NODEJS ? buffer.writeUInt16LE(value, offset) : buffer.setUint16(offset, value, true)\n        case 'uint32': return IS_NODEJS ? buffer.writeUInt32LE(value, offset) : buffer.setUint32(offset, value, true)\n        case 'float': return IS_NODEJS ? buffer.writeFloatLE(value, offset) : buffer.setFloat32(offset, value, true)\n        case 'string': return IS_NODEJS ? buffer.write(value, offset) : writeBufferString(buffer, value, offset)\n        default: {\n          throw new Error('No type specified')\n        }\n      }\n    },\n    getBuffer: () => IS_NODEJS ? buffer : buffer.buffer\n  }\n}\n\nconst readBuffer = (buffer, type, offset = 0) => {\n  switch (type) {\n    case 'uint8': return IS_NODEJS ? buffer.readUInt8(offset) : buffer.getUint8(offset)\n    case 'uint16': return IS_NODEJS ? buffer.readUInt16LE(offset) : buffer.getUint16(offset, true)\n    case 'uint32': return IS_NODEJS ? buffer.readUInt32LE(offset) : buffer.getUint32(offset, true)\n    case 'float': return IS_NODEJS ? buffer.readFloatLE(offset) : buffer.getFloat32(offset, true)\n    default: {\n      throw new Error('No type specified')\n    }\n  }\n}\n\nexport const toBinary = (facets, description, color, material) => {\n  const count = facets.length\n  const size = 84 + count * 12 * 4 + count * 2\n  const { writeBuffer, getBuffer } = createBuffer(size)\n  writeBuffer('string', description)\n  if (color) {\n    writeBuffer('string', ' COLOR=', 47)\n    const [r, g, b, a] = color\n    writeBuffer('uint8', r, 54)\n    writeBuffer('uint8', g, 55)\n    writeBuffer('uint8', b, 56)\n    writeBuffer('uint8', a, 57)\n    if (material) {\n      writeBuffer('string', ',MATERIAL=', 58)\n      const [ diffuse, specular, ambient ] = material\n      writeBuffer('uint32', Colors.getStlColor(diffuse), 68)\n      writeBuffer('uint32', Colors.getStlColor(specular), 72)\n      writeBuffer('uint32', Colors.getStlColor(ambient), 76)\n    }\n  }\n  writeBuffer('uint32', count, 80)\n\n  let offset = 84\n  const write = (value) => {\n    writeBuffer('float', value, offset)\n    offset += 4\n  }\n  for (let j = 0; j<facets.length; j++) {\n    const facet = facets[j]\n    const n = facet.normal || computeNormal(facet.verts)\n    write(n[0])\n    write(n[1])\n    write(n[2])\n    for (var i = 0; i<facet.verts.length; i++) {\n      const vert = facet.verts[i]\n      write(vert[0])\n      write(vert[1])\n      write(vert[2])\n    }\n    const facetColor = facet.color ? Colors.getFacetColor(facet.color) : 0\n    writeBuffer('uint16', facetColor, offset)\n    offset += 2\n  }\n  return getBuffer()\n}\n\nexport const fromBinary = (data) => {\n  const buffer = IS_NODEJS ? Buffer.from(data) : new DataView(data)\n\n  // retrieve description\n  let header = []\n  for (let i = 0; i < 80; ++i) {\n    header.push(readBuffer(buffer, 'uint8', i))\n  }\n  const description = String.fromCharCode(...header)\n\n  // retrieve main color\n  const colorIndex = description.indexOf(' COLOR=')\n  let color = null\n  if (colorIndex !== -1) {\n    color = [\n      readBuffer(buffer, 'uint8', colorIndex + 7),\n      readBuffer(buffer, 'uint8', colorIndex + 8),\n      readBuffer(buffer, 'uint8', colorIndex + 9),\n      readBuffer(buffer, 'uint8', colorIndex + 10)\n    ]\n  }\n\n  // retrieve material\n  const materialIndex = description.indexOf('MATERIAL=')\n  let material = null\n  if (materialIndex !== -1) {\n    material = [\n      readBuffer(buffer, 'uint32', colorIndex + 9),\n      readBuffer(buffer, 'uint32', colorIndex + 13),\n      readBuffer(buffer, 'uint32', colorIndex + 17)\n    ]\n  }\n\n  // retrieve facets\n  const facets = []\n  const countFacets = readBuffer(buffer, 'uint32', 80)\n  let headIndex = 84\n  const read = () => {\n    headIndex += 4\n    return readBuffer(buffer, 'float', headIndex - 4)\n  }\n  for (let i = 0; i < countFacets; ++i) {\n    const normal = [read(), read(), read()]\n    const verts = [\n      [read(), read(), read()],\n      [read(), read(), read()],\n      [read(), read(), read()]\n    ]\n    const facetColor = readBuffer(buffer, 'uint16', headIndex)\n    headIndex += 2\n    facets.push({\n      normal,\n      verts,\n      color: facetColor\n    })\n  }\n  return {\n    description,\n    facets,\n    color,\n    material\n  }\n}","import { toASCII, fromASCII } from './ascii-stl'\nimport { toBinary, fromBinary } from './binary-stl'\n\nconst exportStl = (facets, options = {}) => {\n  const {\n    description = '',\n    binary = true,\n    color = null,\n    material = null\n  } = options\n  if (binary) {\n    // colors exists only in unofficials specs and are exclusive to binary file format\n    // more details: https://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL\n    const stlColor = Array.isArray(color) && color.length === 4 ? color : null\n    let stlMaterial = stlColor && Array.isArray(material) && material.length === 3 ? material : null\n    if (stlMaterial) {\n      const [a,b,c] = material\n      stlMaterial = stlMaterial && Array.isArray(a) && a.length === 3 ? material : null\n      stlMaterial = stlMaterial && Array.isArray(b) && b.length === 3 ? material : null\n      stlMaterial = stlMaterial && Array.isArray(c) && c.length === 3 ? material : null\n    }\n    return toBinary(facets, description, stlColor, stlMaterial)\n  } else {\n    return toASCII(facets, description)\n  }\n}\n\nconst arrayBufferToString = (ab) => {\n  const decoder = new TextDecoder()\n  return decoder.decode(ab)\n}\n\nconst importStl = (data) => {\n  if (typeof data === 'string' && data.slice(0, 6) === 'solid ') {\n    console.log('type: ascii string')\n    return fromASCII(data)\n  } else if (typeof(TextEncoder) !== 'undefined' && typeof data === 'object' && arrayBufferToString(data.slice(0, 6)) === 'solid ') {\n    console.log('type: ascii string in ArrayBuffer (browser only)')\n    return fromASCII(arrayBufferToString(data))\n  } else if (typeof(TextEncoder) === 'undefined' && typeof data === 'object' && data.toString().slice(0, 6) === 'solid ') {\n    console.log('type: ascii string in Buffer (nodeJS only)')\n    return fromASCII(data.toString())\n  } else {\n    console.log('type: binary buffer')\n    return fromBinary(data)\n  }\n}\n\nexport default {\n  exportStl,\n  importStl\n}\n"],"names":["computeNormal","a","b","c","x0","y0","z0","p1x","p1y","p1z","p2x","p2y","p2z","p3x","p3y","p3z","mag","Math","sqrt","map","p","exp","x","y","z","toExponential","asciiFacet","n","v","join","fromASCII","data","split","filter","trim","desc","lines","facets","lineIndex","broken","length","indexOf","push","normal","parseFloat","verts","Error","description","slice","limited","value","max","min","parseInt","facetColorPart","part","toString","padStart","stlColorPart","r","g","Number","IS_NODEJS","undefined","Boolean","Buffer","e","readBuffer","buffer","type","offset","readUInt8","getUint8","readUInt16LE","getUint16","readUInt32LE","getUint32","readFloatLE","getFloat32","arrayBufferToString","ab","TextDecoder","decode","exportStl","options","binary","color","material","stlColor","Array","isArray","stlMaterial","count","size","alloc","DataView","ArrayBuffer","fill","writeBuffer","writeUInt8","setUint8","writeUInt16LE","setUint16","writeUInt32LE","setUint32","writeFloatLE","setFloat32","write","step","forEach","char","charCodeAt","writeBufferString","getBuffer","createBuffer","specular","ambient","Colors","j","facet","i","vert","facetColor","toBinary","str","toASCII","importStl","console","log","TextEncoder","from","header","String","fromCharCode","colorIndex","countFacets","headIndex","read","fromBinary"],"mappings":"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"}